[{"categories":null,"contents":"类图六大关系 类与类之间的关系分为六种：\n依赖（Dependence） 泛化/继承（Generalization） 实现（Implementation） 关联（Association） 聚合（Aggregation） 组合（Composition） 依赖关系（Dependence） 只要类中用到了对方即构成依赖关系。\n类的成员属性 方法的返回类型 方法接收的参数类型 方法内部使用到 泛化关系（Generalization） 泛化关系其实就继承关系，它是依赖关系的特例\n实现关系（Implementation） 实际上就是A类实现B类，实现关系是依赖关系的特例\n关联关系（Association） 关联关系实际是 类与类之间的联系，他是依赖关系的特例\n特点： 具有导航性：即单向关系与双向关系 具有多重性： 0 ， 1 ， *\n聚合关系（Aggregation） 聚合关系表示整体与部分的关系，部分可以与整体分开。 聚合关系是关联关系的特例,因此也具有导航性与多重性\neg: person 与 IDCard 的关系\n组合关系（Composition） 也是整体与部分的关系，只是整体与部分不可分开\neg: person 与 head 的关系\n","date":"2020-05-03","permalink":"https://blog.singasoong.top/posts/designpattern/designpattern-0-classdiagram/","summary":"类图六大关系 类与类之间的关系分为六种： 依赖（Dependence） 泛化/继承（Generalization） 实现（Implementatio","tags":["DesignPattern","类图"],"title":"设计模式-类图（第0篇）"},{"categories":null,"contents":"设计模式的七大设计原则 单一职责原则：一个类应该只负责一项职责； 接口隔离原则：客户端不应该依赖它不需要的接口，即一个类对另一个接口的依赖应该建立在最小的接口上； 依赖倒转原则： 高层模块不应该依赖低层模块，两者都应该依赖其抽象 抽象不要依赖细节，细节应该依赖抽象 依赖倒转（倒置）的中心思想是面向接口编程 里氏替换原则： 里氏替换原则在1988年，由麻省理工学院的一位姓里的女士提出的 如果对每个类型为T1的对象o1,都有类型为T2的对象o2,使得以T1定义的所有程序P在所有的对象o1都替换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。 换句话说，所有引用基类的地方必须能透明地使用其子类的对象 在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法 里氏替换原则告诉我们，继承实际上是让两个类的耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖来解决问题。 开闭原则： 是编程中最基础、最重要的设计原则 一个软件实体类、模块和函数应该对扩展开发，对修改关闭。用抽象构建框架，用实现扩展细节 当软件变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现 编程中遵循其他原则，以及使用设计模式的目的就是遵循开闭原则 迪米特法则 一个对象应对其他对象保持最少的了解 类与类关系越密切，耦合性越大 迪米特法则又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都应将逻辑封装在类的内部。对外除了提供public方法不对外泄露任何信息 迪米特法则还有一个更简单的定义：只与直接朋友通信（成员变量，方法参数，方法返回值中的类为直接朋友，局部变量中的类不是直接朋友） 合成复用原则：尽量使用合成/聚合的方式，而不是使用继承 题外话： 接口和抽象类存在的价值在于设计，规范\n设计模式类型 设计模式分为三类，共23种\n创建型模式（共5种）：\n单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式\n结构型模式（共7种）：\n适配器模式、桥接模式、装饰者模式、组合模式、外观模式、享元模式、代理模式\n行为型模式（共11种）： 模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式\n","date":"2020-05-03","permalink":"https://blog.singasoong.top/posts/designpattern/designpattern-1-overview/","summary":"设计模式的七大设计原则 单一职责原则：一个类应该只负责一项职责； 接口隔离原则：客户端不应该依赖它不需要的接口，即一个类对另一个接口的依赖应该建","tags":["DesignPattern"],"title":"设计模式-概览与分类（第1篇）"},{"categories":null,"contents":"创建型设计模式 通过\u0026quot;对象创建\u0026quot;模式绕开new, 来避免对象创建(new)过程中所导致的紧耦合(依赖具体类),从而支持对象创建的稳定.它是借口抽象后的第一步工作.\n上篇说道创建型设计模式一共五种，分别为：\n单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式，下面分别详细的讲解这五种模式。\n各模式代码演示源码请访问\n单例模式 单例模式就是采取一定的方法保证在整个软件系统中，对某个类只存在一个对象实例，并且该类只提供一个取得其对象实例的方法（静态方法）\n这里说道的采取一定的方法一般有以下几种：\n饿汉式（静态常量）\n构造器私有化（防止new）\n类的内部创建对象（申明成员变量的时候直接new）\n向外暴露一个静态的公共方法\nclass Singleton01{ private final static Singleton01 instance = new Singleton01(); private Singleton01() { } public static Singleton01 getInstance(){ return instance; } } 饿汉式（静态代码块）\n同上\n不同之处在于创建对象是在静态代码块中完成 饿汉式优缺点：\n优点：简单，在类装载的时候就完成实例化，避免线程同步的问题\n缺点：没有达到lazy loading 的效果，造成内存浪费\nclass Singleton02{ private final static Singleton02 instance; static { instance = new Singleton02(); } private Singleton02() { } public static Singleton02 getInstance(){ return instance; } } 懒汉式（线程不安全）不可用\n线程不安全 不可用 class Singleton01 { private static Singleton01 instance; private Singleton01() { } public static Singleton01 getInstance() { // 该方法不能保证线程安全 if (null == instance) { instance = new Singleton01(); } return instance; } } 懒汉式（线程安全，同步方法）\n可用但是在方法上加同步锁，效率低 class Singleton02 { private static Singleton02 instance; private Singleton02() { } /* 方法上加同步锁，效率低 */ public static synchronized Singleton02 getInstance() { if (null == instance) { instance = new Singleton02(); } return instance; } } 懒汉式（线程不安全， 同步代码块）\n不可用 class Singleton03 { private static Singleton03 instance; private Singleton03() { } public static Singleton03 getInstance() { // 该方法不能保证线程安全 if (null == instance) { //此处线程不安全 synchronized (Singleton03.class) { instance = new Singleton03(); } } return instance; } } 双重检查 提供一个静态的公共方法，加入双重检查的代码，解决线程安全的问题，同时解决懒加载的问题\n同时保证了效率，推荐使用\nclass Singleton { private static volatile Singleton instance; private Singleton() { } public static Singleton getInstance() { if (null == instance) { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } } return instance; } } 静态内部类\n外部类装载的时候，静态内部类并不会装载\n当用到这个静态内部类的时候才回去装载，类在装载的时候没有线程同步的问题\n因此该问题即解决了线程同步的问题同时也达到了懒加载的效果，建议使用\n/** * 静态内部类 */ class Singleton1 { private Singleton1() { } private static class SingletonInstance { private static volatile Singleton1 INSTANCE = new Singleton1(); } public static Singleton1 getInstance() { return SingletonInstance.INSTANCE; } } 枚举\n借助jdk1.5中添加的枚举来实现单例模式，不仅能避免多线程同步的问题，而且还能防止反序列化重新创建对象\n该方式是Effective Java 作者 Josh Bloch 提倡的方式\n推荐使用\n/** * 枚举 */ enum Singleton2 { INSTANCE; public void sayOK() { System.out.println(\u0026#34;hha\u0026#34;); } } 抽象工厂模式 提供一个接口,让该接口负责创建一系列\u0026quot;相关或者相互依赖的对象\u0026quot;, 无需指定它们具体的类\n工厂模式 工厂方法模式 定义一个用于创建对象的接口, 让子类决定实例化哪一个类.Factory Method 使得一个类的实例化延迟(目的:解耦)到子类\n一个对象对应一个工厂\n原型模式 使用原型实例指定创建对象的种类,然后通过拷贝这些原型来创建新的对象\n建造者模式 动机: 一个复杂对象的创建工作\n定义: 将一个复杂的对象的构建与其表示相分离,使得同样的构建过程(稳定)可以创建不同的表示(变化)\n","date":"2020-05-04","permalink":"https://blog.singasoong.top/posts/designpattern/designpattern-2-creational/","summary":"创建型设计模式 通过\u0026quot;对象创建\u0026quot;模式绕开new, 来避免对象创建(new)过程中所导致的紧耦合(依赖具体类),从而支持对象创","tags":["DesignPattern"],"title":"设计模式-创建型模式（第2篇）"},{"categories":null,"contents":"结构型模式 通过类继承或者对象组合获得灵活的结构，从而应对需求变化为对象的结构带来冲击\n结构型模式分类一共有7种:适配器模式、桥接模式、装饰者模式、组合模式、外观模式、享元模式、代理模式\n适配器模式 桥接模式 定义：将抽象部分（业务功能）与实现部分（平台实现）分离，使它们都可以独立的变化。\n动机： 类图： 总结： 装饰者模式 定义：动态（组合）地给一个对象增加一些额外的职责，就增加功能而言，Decorator模式比生成子类（继承）更加灵活（消除重复代码\u0026amp;减少子类个数）\n场景：IO Stream\n动机 类图： 总结： 组合模式 外观模式 享元模式 定义：运用共享技术有效地支持大量细粒度 的对象。\n动机： 类图： 代理模式 ","date":"2021-10-14","permalink":"https://blog.singasoong.top/posts/designpattern/designpattern-3-structural/","summary":"结构型模式 通过类继承或者对象组合获得灵活的结构，从而应对需求变化为对象的结构带来冲击 结构型模式分类一共有7种:适配器模式、桥接模式、装饰者模","tags":["DesignPattern"],"title":"设计模式-结构型模式（第3篇）"},{"categories":null,"contents":"行为型模式 通过类继承或者对象组合来划分类与对象的职责，从而应对需求变化为多个交互的对象的冲击\n行为型型模式分类一共有7种：模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式\n模板方法模式 定义：定义一个操作中的算法的骨架（稳定），而将一些步骤延迟（变化）到子类。Template Method使得子类既可以不改变（复用）一个算法的结构也可重定义（override 重写）该算法的某些特定步骤。\n动机：\n类图：\n策略模式 定义一系列算法，把他们一个一个封装起来，并且使他们可互相替换（变化）。该模式使得算法可独立于使用它的客户程序（稳定）而变化（扩展，子类化）\n类图： 观察者模式 定义：定义对象间的一种一对多（变化）的依赖关系，以便当一个对象（subject）的状态发生改变时，所有依赖于它的对象都得到通知并自动更新\n场景：消息订阅\n动机：\n类图： 总结：\n命令模式 访问者模式 迭代器模式 中介者模式 备忘录模式 解释器模式 状态模式 职责链模式 ","date":"2021-10-15","permalink":"https://blog.singasoong.top/posts/designpattern/designpattern-4-behavioral/","summary":"行为型模式 通过类继承或者对象组合来划分类与对象的职责，从而应对需求变化为多个交互的对象的冲击 行为型型模式分类一共有7种：模板方法模式、命令模","tags":["DesignPattern"],"title":"设计模式-行为型模式（第4篇）"},{"categories":null,"contents":" 我们在开发过程中经常会遇到https 请求失败的问题：PKIX path building failed，这往往是由于网站使用自签证书，不是官方证书授权机构授权的证书，在请求加密过程中证书验证失败导致。详细如下报错：\nCaused by: javax.net.ssl.SSLHandshakeException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target at java.base/sun.security.ssl.Alert.createSSLException(Alert.java:131) at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:369) at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:312) at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:307) ... 那么接下来我们来总结下解决这个问题的几个方法： 首先得下载证书 参考如下图 1. 将证书添加到本地JVM的信任存储库 keytool -import -trustcacerts -keystore \u0026#34;%JAVA_HOME%\\jre\\lib\\security\\cacerts\u0026#34; -storepass changeit -alias \u0026#34;your alias\u0026#34; -import \u0026#34;path_to_cert_file\u0026#34; 导入成功后重启应用即可。\n2. 使用自定义信任库 可以将证书导入到一个自定义的证书库（参考上面，keystore后面指定你自定义路径），然后通过代码指定你的信任库文件\nSystem.setProperty(\u0026#34;javax.net.ssl.trustStore\u0026#34;, \u0026#34;/path/to/cert/cacerts\u0026#34;); System.setProperty(\u0026#34;javax.net.ssl.trustStorePassword\u0026#34;, \u0026#34;changeit\u0026#34;); 或者是通过程序启动JVM参数\n-Djavax.net.ssl.trustStore # 指定 TrustStore 文件的路径。 -Djavax.net.ssl.trustStorePassword # 指定 TrustStore 文件的密码。 -Djavax.net.ssl.trustStoreType #指定 TrustStore 文件的类型，默认是 `JKS`。其他常见类型包括 `PKCS12` 还有一种，如果项目使用SpringBoot， 可以通过在配置文件使用server.ssl.trust-store server.ssl.trust-store-password 来指定，但是我没有成功。\n","date":"2024-12-23","permalink":"https://blog.singasoong.top/posts/https_cert_trust/","summary":"我们在开发过程中经常会遇到https 请求失败的问题：PKIX path building failed，这往往是由于网站使用自签证书，不是官方证书授权机构授权的证书，","tags":["java"],"title":"报错 | PKIX path building failed"},{"categories":null,"contents":"安装ACME curl https://get.acme.sh | sh # 安装socat： apt install socat # 添加软链接： ln -s /root/.acme.sh/acme.sh /usr/local/bin/acme.sh # 注册账号： acme.sh --register-account -m my@example.com # 开放80端口： ufw allow 80 申请证书 申请证书前需要先确保80端口处于打开状态。\n# 申请证书 acme.sh --issue -d `your domain` --standalone -k ec-256 # 安装证书： acme.sh --installcert -d `your domain` --ecc \\ --key-file /root/trojan/server.key \\ --fullchain-file /root/trojan/server.crt # 如果默认CA无法颁发，则可以切换下列CA： # 切换 Let’s Encrypt： acme.sh --set-default-ca --server letsencrypt # 切换 Buypass： acme.sh --set-default-ca --server buypass # 切换 ZeroSSL： acme.sh --set-default-ca --server zerossl ","date":"2023-09-22","permalink":"https://blog.singasoong.top/posts/ssl-%E4%B9%8B%E7%94%B3%E8%AF%B7%E8%AF%81%E4%B9%A6/","summary":"安装ACME curl https://get.acme.sh | sh # 安装socat： apt install socat # 添加软链接： ln -s /root/.acme.sh/acme.sh /usr/local/bin/acme.sh # 注册账号： acme.sh --register-account -m my@example.com # 开放80端口： ufw allow 80 申请证书 申请证书前需要先确保80","tags":["SSL"],"title":"SSL证书之acme"},{"categories":null,"contents":"What is SSO? Single sign-on (SSO) is an authentication method that enables users to securely authenticate with multiple applications and websites by using just one set of credentials.\nHow Does Single Sign-On (SSO) protocol Work? There are two commonly used SSO protocols namely SAML and OAuth2.\nOAuth2 Role OAuth defines four roles:\nresource owner An entity capable of granting access to a protected resource. When the resource owner is a person, it is referred to as an end-user.\nresource server The server hosting the protected resources, capable of accepting and responding to protected resource requests using access tokens.\nclient An application making protected resource requests on behalf of the resource owner and with its authorization. The term \u0026ldquo;client\u0026rdquo; does not imply any particular implementation characteristics (e.g., whether the application executes on a server, a desktop, or other devices).\nauthorization server The server issuing access tokens to the client after successfully authenticating the resource owner and obtaining authorization.\nProtocol Flow Please refer to this link for the OAuth 2.0 authorization framework details: RFC 6749\nThe main process as below:\nThe abstract OAuth 2.0 flow illustrated in above figure describes the interaction between the four roles and includes the following steps:\n(A) - The client requests authorization from the resource owner. The authorization request can be made directly to the resource owner(as shown), or preferably indirectly via the authorization server as an intermediary.\n(B) - The client receives an authorization grant, which is a credential representing the resource owner\u0026rsquo;s authorization, expressed using one of four grant types defined in this specification or using an extension grant type. The authorization grant type depends on the method used by the client to request authorization and the types supported by the authorization server.\n(C) - The client requests an access token by authenticating with the authorization server and presenting the authorization grant.\n(D) - The authorization server authenticates the client and validates the authorization grant, and if valid, issues an access token.\n(E) - The client requests the protected resource from the resource server and authenticates by presenting the access token.\n(F) - The resource server validates the access token, and if valid, serves the request.\nObtaining Authorization To request an access token, the client obtains authorization from the resource owner. The authorization is expressed in the form of an authorization grant, which the client uses to request the access token. OAuth defines four grant types:\nauthorization code implicit resource owner password credentials client credentials. It also provides an extension mechanism for defining additional grant types. Authorization Code Grant Flow The authorization code grant type is used to obtain both access tokens and refresh tokens and is optimized for confidential clients. Since this is a redirection-based flow, the client must be capable of interacting with the resource owner\u0026rsquo;s user-agent (typically a web browser) and capable of receiving incoming requests (via redirection) from the authorization server.\nThe flow illustrated in Figure 3 includes the following steps:\n(A) - The client initiates the flow by directing the resource owner\u0026rsquo;s user-agent to the authorization endpoint. The client includes its client identifier, requested scope, local state, and a redirection URI to which the authorization server will send the user-agent back once access is granted (or denied).\n(B) - The authorization server authenticates the resource owner (via the user-agent) and establishes whether the resource owner grants or denies the client\u0026rsquo;s access request.\n(C) - Assuming the resource owner grants access, the authorization server redirects the user-agent back to the client using the redirection URI provided earlier (in the request or during client registration). The redirection URI includes an authorization code and any local state provided by the client earlier.\n(D) - The client requests an access token from the authorization server\u0026rsquo;s token endpoint by including the authorization code received in the previous step. When making the request, the client authenticates with the authorization server. The client includes the redirection URI used to obtain the authorization code for verification.\n(E) - The authorization server authenticates the client, validates the authorization code, and ensures that the redirection URI received matches the URI used to redirect the client in step (C). If valid, the authorization server responds back with an access token and, optionally, a refresh token.\nSAML 2.0 The SAML 2.0(Security Assertion Markup Language) Login feature provides an application with the capability to act as a SAML 2.0 Relying Party, having users log in to the application by using their existing account at a SAML 2.0 Asserting Party (Okta, ADFS, etc).\nRole Principal Service Provider(SP) - web service(like EDL) Identity Provider(IdP) - Microsoft, AWS \u0026hellip; Main Process The main process as below: First, a user makes an unauthenticated request to the resource /private for which it is not authorized. Spring Security’s FilterSecurityInterceptor indicates that the unauthenticated request is Denied by throwing an AccessDeniedException. Since the user lacks authorization, the ExceptionTranslationFilter initiates Start Authentication. The configured AuthenticationEntryPoint is an instance of LoginUrlAuthenticationEntryPoint which redirects to the \u0026lt;saml2:AuthnRequest\u0026gt; generating endpoint, Saml2WebSsoAuthenticationRequestFilter. Or, if you’ve configured more than one asserting party, it will first redirect to a picker page. Next, the Saml2WebSsoAuthenticationRequestFilter creates, signs, serializes, and encodes a \u0026lt;saml2:AuthnRequest\u0026gt; using its configured Saml2AuthenticationRequestFactory. Then, the browser takes this \u0026lt;saml2:AuthnRequest\u0026gt; and presents it to the asserting party. The asserting party attempts to authentication the user. If successful, it will return a \u0026lt;saml2:Response\u0026gt; back to the browser. The browser then POSTs the \u0026lt;saml2:Response\u0026gt; to the assertion consumer service endpoint. Usage in Java(Spring Security) Please refer to this link for details: Spring Security\n","date":"2023-09-20","permalink":"https://blog.singasoong.top/posts/sso/","summary":"What is SSO? Single sign-on (SSO) is an authentication method that enables users to securely authenticate with multiple applications and websites by using just one set of credentials. How Does Single Sign-On (SSO) protocol Work? There are two commonly used SSO protocols namely SAML and OAuth2. OAuth2 Role OAuth defines four roles: resource owner An entity capable of granting access to a protected resource. When the resource owner is a","tags":["笔记"],"title":"SSO 笔记"},{"categories":null,"contents":"Binary Tree(二叉树) Introduction A tree is a frequently-used data structure to simulate a hierarchical tree structure.\n树是经常使用的数据结构，以模拟分层树结构。\nEach node of the tree will have a root value and a list of references to other nodes which are called child nodes. From graph view, a tree can also be defined as a directed acyclic graph which has N nodes and N-1 edges.\n树的每个节点都有一个根值和对其他节点(称为子节点)的引用列表。从图形的角度来看，一棵树也可以定义为一个有 N 个节点和 N-1条边的有向无环图。\nA Binary Tree is one of the most typical tree structure. As the name suggests, a binary tree is a tree data structure in which each node has at most two children, which are referred to as the left child and the right child.\n二叉树是最典型的树结构之一。顾名思义，二叉树是一种树型数据结构，其中每个节点最多有两个子节点，即左子节点和右子节点。\nTraverse a Tree Pre-order Traversal - 前序 Pre-order traversal is to visit the root first. Then traverse the left subtree. Finally, traverse the right subtree.\n预序遍历是先访问根，然后遍历左侧子树，最后遍历右侧子树。\n/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func preorderTraversal(root *TreeNode) []int { res := []int{} if(root == nil){ return res } res = append(res, root.Val) res = append(res, preorderTraversal(root.Left)...) res = append(res, preorderTraversal(root.Right)...) return res } In-order Traversal - 中序 In-order traversal is to traverse the left subtree first. Then visit the root. Finally, traverse the right subtree.\n顺序遍历是先遍历左边的子树，然后访问根，最后遍历右边的子树。\n/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func inorderTraversal(root *TreeNode) []int { res := []int{} if(root == nil){ return res } res = append(res, inorderTraversal(root.Left)...) res = append(res, root.Val) res = append(res, inorderTraversal(root.Right)...) return res } Post-order Traversal - 后序 Post-order traversal is to traverse the left subtree first. Then traverse the right subtree. Finally, visit the root.\n后序遍历是先遍历左侧子树，然后遍历右侧子树，最后访问根。\n/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func postorderTraversal(root *TreeNode) []int { res := []int{} if(root == nil){ return res } res = append(res, postorderTraversal(root.Left)...) res = append(res, postorderTraversal(root.Right)...) return append(res, root.Val) } Level Order Traversal - 层序 Level-order traversal is to traverse the tree level by level.\n层序遍历就是逐层遍历树。\n/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func levelOrder(root *TreeNode) [][]int { res := [][]int{} if(root == nil){ return res } cur := []*TreeNode{root} for len(cur) \u0026gt; 0 { next := []*TreeNode{} res_level := make([]int, len(cur)) for i, node := range(cur){ res_level[i] = node.Val if(node.Left != nil){ next = append(next, node.Left) } if(node.Right != nil){ next = append(next, node.Right) } } res = append(res, res_level) cur = next } return res } Recursive or Iterative 递归和迭代\n","date":"2023-08-24","permalink":"https://blog.singasoong.top/posts/leetcode/explorelearn/","summary":"Binary Tree(二叉树) Introduction A tree is a frequently-used data structure to simulate a hierarchical tree structure. 树是经常使用的数据结构，以模拟分层树结构。 Each node of the tree will have a root value and a list of references to other nodes which are called child nodes. From graph","tags":["concept"],"title":"Leetcode之探索学习"},{"categories":null,"contents":"介绍 Keytool 是一个Java 数字证书的管理工具， Keytool将密钥（key）和证书（certificates）存在一个称为keystore的文件中 在keystore里，包含两种数据：\n密钥实体（Key entity）——密钥（secret key）又或者是私钥和配对公钥（采用非对称加密） 可信任的证书实体（trusted certificate entries）——只包含公钥 命令 Help information ✗ keytool -h Key and Certificate Management Tool Commands: -certreq Generates a certificate request -changealias Changes an entry\u0026#39;s alias -delete Deletes an entry -exportcert Exports certificate -genkeypair Generates a key pair -genseckey Generates a secret key -gencert Generates certificate from a certificate request -importcert Imports a certificate or a certificate chain -importpass Imports a password -importkeystore Imports one or all entries from another keystore -keypasswd Changes the key password of an entry -list Lists entries in a keystore -printcert Prints the content of a certificate -printcertreq Prints the content of a certificate request -printcrl Prints the content of a CRL file -storepasswd Changes the store password of a keystore Use \u0026#34;keytool -?, -h, or --help\u0026#34; for this help message Use \u0026#34;keytool -command_name --help\u0026#34; for usage of command_name. Use the -conf \u0026lt;url\u0026gt; option to specify a pre-configured options file. keytool -list 列出密钥存储库中的证书信息\nHelp information ✗ keytool -list -h keytool -list [OPTION]... Lists entries in a keystore Options: -rfc output in RFC style -alias \u0026lt;alias\u0026gt; alias name of the entry to process -keystore \u0026lt;keystore\u0026gt; keystore name -cacerts access the cacerts keystore -storepass \u0026lt;arg\u0026gt; keystore password -storetype \u0026lt;type\u0026gt; keystore type -providername \u0026lt;name\u0026gt; provider name -addprovider \u0026lt;name\u0026gt; add security provider by name (e.g. SunPKCS11) [-providerarg \u0026lt;arg\u0026gt;] configure argument for -addprovider -providerclass \u0026lt;class\u0026gt; add security provider by fully-qualified class name [-providerarg \u0026lt;arg\u0026gt;] configure argument for -providerclass -providerpath \u0026lt;list\u0026gt; provider classpath -v verbose output -protected password through protected mechanism Demo # 查看证书列表 keytool -list -keystore {path}/cacerts # 查看证书详细信息 以列表展示 keytool -list -keystore -v {path}/cacerts keytool -import 证书导入\ncertAlias 证书别名, 不能重复 不区分大小写\n# 导入证书 keytool -import -alias {certAlias} -file \u0026#39;{path}/certfile.crt\u0026#39; -keystore \u0026#39;{path}/java/openjdk/lib/security/cacerts\u0026#39; keytool -export 证书导出\nkeytool -exportcert \\ -rfc \\ -alias example \\ -file cert.pem \\ -keystore example.p12 \\ -storepass changeit \\ -storetype PKCS12 \\ -v -rfc : Will output in PEM format as defined by RFC 1421. -alias : The alias of the entry encapsulated in the keystore. The chosen value should enhance the readability of the keystore entries, especially when the keystore contains multiple entries. -file : The file to contain the exported X.509 certificate. -keystore : The filename of the keystore. -storepass : The current keystore password. We recommend leaving this option off and letting keytool prompt you instead of writing your password in plain text here. -storetype : Recommended keystore types include PKCS12 and JKS. In this case, the keystore was of type PKCS12. -v : Verbose output. ","date":"2023-08-21","permalink":"https://blog.singasoong.top/posts/keytool%E5%91%BD%E4%BB%A4/","summary":"介绍 Keytool 是一个Java 数字证书的管理工具， Keytool将密钥（key）和证书（certificates）存在一个称为keystore的文件中","tags":["命令"],"title":"Keytool 命令"},{"categories":null,"contents":"前言 最近想把家里网络升级一下 于是购置了一套Tplink APAC 组网设备 家里已有网络环境 光纤入户-\u0026gt; 一台N3540主路由（拨号\u0026amp;DHCP）-\u0026gt; Redmi AC2100(桥接\u0026amp; 提供wifi) 主路由 192.168.100.1\n组网 家里所有设备在同一网段，正常上网（包括科学上网） 商云App可以查看AP状态与管理所有AP 方案一：TP-Link 作为二级路由 N3540仍然做主路由，Lan口接AC交换机的Wan口，AC Wan口自动获取Ip 或者静态IP都可，Lan口开启DHCP。\n优点：该方案是可用的，商云APP可以正常发现并管理AP设备，配置简单现有网络基础上不需要做太多的变化，只需替换原来的Redmi 路由器即可 缺点：不满足我的需求1，主路由与AP不在同一网段。多一级路由对网络传输会有损耗也增加了网络的复杂度 总结：该方案不推荐\n方案二：TP-Link AC 仅作为交换机使用 AC交换机先不接上游网络（Wan先不接线）Lan口连接所有AP,通过wifi或者网线设置AC,AC Wan口可不做设置或设置自动获取IP，AC Lan口设置静态IP（与主路由保持同一网段如：192.168.100.233）并关闭DHCP服务。N3540仍然做主路由，最后N3540Lan口接AC交换机的Lan口。\n优点：整个网络只有主路由提供DHCP服务，所以所有设备均在同一网段，且所有设备能正常上网并跑满带宽 缺点：由于AC Wan口没有使用仅作为交换机，所有没有接入互联网不能使用商云APP(咨询了客服是这样解释的)也就不能通过商云app 管理AP,但是 可以通过AC IP(192.168.100.233)进入网页UI进行查看网络情况 总结：方案可行，没有强迫症对商云APP没有执念可以尝试\n方案三：N3540做旁路由（也叫旁路网关） 经过前面两种方案的尝试，方案都并不完美，最终通过一番搜索与学习，最终决定将主路由用作旁路由，AC升级作为主路由。 首先光猫网线出来直接接入ACWan口，进入路由器控制中心Wan口输入账号密码进行拨号,Lan口设置静态IP(如：192.168.100.233),开启DHCP. image.png N3540做旁路由Lan口接入AC Lan口，修改设置：\nLan口选择静态地址（与AC主路由保持网段一致，如192.168.100.1）；网关设置成AC 主路由地址（192.168.100.233）这很重要。 Lan口关闭DHCP服务 进入防火墙，修改Lan 防火墙设置，勾选“IP 动态伪装” 至此N3540设置完毕。至此N3540仅作为一个网络设备不会对整个网络有任何影响。连接APwifi 手机等设备也能正常上网，但是还不能科学上网。 还要进行一部配置，将联网设备的网关指向旁路由。该配置有两种方式：非侵入式与侵入式\n非侵入式：联网设备进行联网配置，自动获取IP改为手动设置 需要特殊注意的是将网关配置成旁路由IP（即192.168.100.1）重新连接后即可上网。该方案优点就是可以控制哪些设备需要经旁路由。缺点就是比较麻烦 每个需要科学上网的设备都需要手动配置， 侵入式：基于上面一种方案，该方案是将该配置通过DHCP下发给所有联网设备，在AC Lan口的DHCP配置中填入旁路由IP（即192.168.100.1）所有设备重新联网即可。该方案也有缺点，有侵入性，如果旁路由挂掉 整个网络即瘫痪（该场景应该很少） 至此所有配置完成。\n优点：满足我的两点基本需求。所有设备正常上网，跑满带宽。商云APP 正常发现并管理AP设备 缺点：配置稍微麻烦一点 总结：目前是我的最佳解决方案，推荐。如果后续有方案变更再做更新。有小伙伴有更好的方式可进行讨论分享[emoji:抱拳]\n","date":"2023-06-04","permalink":"https://blog.singasoong.top/posts/openwrt-tplink-acap-deploy/","summary":"前言 最近想把家里网络升级一下 于是购置了一套Tplink APAC 组网设备 家里已有网络环境 光纤入户-\u0026gt; 一台N3540主路由（拨号\u0026amp;DHC","tags":["网络","家庭组网"],"title":"部署｜Openwrt + Tplink ACAP"},{"categories":null,"contents":"一、Docker介绍 1. 下载Docker依赖的环境 # 想安装Docker，需要先将依赖的环境全部下载下来，就像Maven依赖JDK一样 yum -y install yum-utils device-mapper-persistent-data lvm2 2. 指定Docker镜像源 # 默认下载Docker会去国外服务器下载，速度较慢，可以设置为阿里云镜像源，速度更快 yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 3. 安装docker yum makecache fast yum -y install docker-ce 4. 启动Docker并测试 安装成功后，需要手动启动，设置为开机启动，并测试一下 Docker #启动docker服务 systemctl start docker #设置开机自动启动 systemctl enable docker #测试 docker run hello-world 二、 Docker的中央仓库 # 1.Docker官方的中央仓库：这个仓库是镜像最全的，但是下载速度较慢。 https://hub.docker.com/ # 2.国内的镜像网站：网易蜂巢，daoCloud等，下载速度快，但是镜像相对不全。 https://c.163yun.com/hub#/home http://hub.daocloud.io/ （推荐使用） # 3.在公司内部会采用私服的方式拉取镜像（添加配置） #需要创建 /etc/docker/daemon.json，并添加如下内容 { \u0026#34;registry-mirrors\u0026#34;:[\u0026#34;https://registry.docker-cn.com\u0026#34;], \u0026#34;insecure-registries\u0026#34;:[\u0026#34;ip:port\u0026#34;] } # 重启两个服务 systemctl daemon-reload systemctl restart docker 三、 镜像的操作 1. 拉取镜像 # 从中央仓库拉取镜像到本地 docker pull 镜像名称[:tag] # 举个栗子: docker pull daocloud.io/library/tomcat:8.5.15-jre8 2. 查看本地所有镜像 # 查看本地已经安装过的镜像信息，包含标识，名称，版本，更新时间，大小 docker images 3. 删除本地镜像 # 镜像会占用磁盘空间，可以直接手动删除，标识通过查看获取 docker rmi 镜像的标识 4. 镜像的导入导出 # 如果因为网络原因可以通过硬盘的方式传输镜像，虽然不规范，但是有效，但是这种方式导出的镜像名称和版本都是null，需要手动修改 # 将本地的镜像导出 docker save -o 导出的路径 镜像id # 加载本地的镜像文件 docker load -i 镜像文件 # 修改镜像文件 docker tag 镜像id 新镜像名称：版本 四、 容器的操作 1. 运行容器 # 运行容器需要定制具体镜像，如果镜像不存在，会直接下载 #简单操作 docker run 镜像的标识|镜像的名称[:tag] #常用的参数 docker run -d -p 宿主机端口:容器端口 --name 容器名称 镜像的标识|镜像名称[:tag] #-d:代表后台运行容器 #-p 宿主机端口:容器端口：为了映射当前Linux的端口和容器的端口 #--name 容器名称:指定容器的名称 2. 查看正在运行的容器 # 查看全部正在运行的容器信息 docker ps [-qa] #-a 查看全部的容器，包括没有运行 #-q 只查看容器的标识 3. 查看容器日志 # 查看容器日志，以查看容器运行的信息 docker logs -f 容器id #-f：可以滚动查看日志的最后几行 4. 进入容器的内部 # 可以进入容器的内部进行操作 docker exec -it 容器id bash 5. 复制内容到容器 # 将宿主机的文件复制到容器内部的指定目录 docker cp 文件名称 容器id:容器内部路径 6. 重启\u0026amp;启动\u0026amp;停止\u0026amp;删除容器 容器的启动，停止，删除等操作，后续会经常使用到 #重新启动容器 docker restart 容器id #启动停止运行的容器 docker start 容器id #停止指定的容器(删除容器前，需要先停止容器) docker stop 容器id #停止全部容器 docker stop $(docker ps -qa) #删除指定容器 docker rm 容器id #删除全部容器 docker rm $(docker ps -qa) 五、Dockerfile //todo\n六、Docker Compose //todo\n","date":"2020-11-11","permalink":"https://blog.singasoong.top/posts/docker/","summary":"一、Docker介绍 1. 下载Docker依赖的环境 # 想安装Docker，需要先将依赖的环境全部下载下来，就像Maven依赖JDK一样 yum -y install yum-utils device-mapper-persistent-data","tags":["docker"],"title":"笔记｜Docker 笔记"},{"categories":null,"contents":"语法 1.普通字符 普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。\n2.非打印字符 非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：\n\\cx # 匹配由x指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，s将 c 视为一个原义的 \u0026#39;c\u0026#39; 字符。 \\f #匹配一个换页符。等价于 \\x0c 和 \\cL。 \\n #匹配一个换行符。等价于 \\x0a 和 \\cJ。 \\r #匹配一个回车符。等价于 \\x0d 和 \\cM。 \\s #匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。 \\S #匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。 \\t #匹配一个制表符。等价于 \\x09 和 \\cI。 \\v #匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 3.特殊字符 所谓特殊字符，就是一些有特殊含义的字符，如上面说的 runoob 中的，简单的说就是表示任何字符串的意思。 如果要查找字符串中的 符号，则需要对进行转义，即在其前加一个 : runo*ob 匹配 runo*ob。 许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符\u0026quot;转义\u0026quot;，即，将反斜杠字符\\ 放在它们前面。下表列出了正则表达式中的特殊字符：\n$ #匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 \u0026#34;\\n\u0026#34; 或 \u0026#34;\\r\u0026#34;。要匹配 $ 字符本身，请使用 \\$。 ( ) # 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \\( 和 \\)。 * #匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \\*。 + #匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \\+。 . #匹配除换行符 \\n 之外的任何单字符。要匹配 . ，请使用 \\. 。 [ #标记一个中括号表达式的开始。要匹配 [，请使用 \\[。 ? #匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \\?。 \\ #将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。 #例如，\u0026#39;n\u0026#39; 匹配字符 \u0026#39;n\u0026#39;。\u0026#39;\\n\u0026#39; 匹配换行符。序列 \u0026#39;\\\\\u0026#39; 匹配 \u0026#34;\\\u0026#34;，而 \u0026#39;\\(\u0026#39; 则匹配 \u0026#34;(\u0026#34;。 ^ #匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \\^。 { #标记限定符表达式的开始。要匹配 {，请使用 \\{。 | #指明两项之间的一个选择。要匹配 |，请使用 \\|。 4.限定符 限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。\n* #匹配前面的子表达式零次或多次。例如，zo* 能匹配 \u0026#34;z\u0026#34; 以及 \u0026#34;zoo\u0026#34;。* 等价于{0,}。 + #匹配前面的子表达式一次或多次。例如，\u0026#39;zo+\u0026#39; 能匹配 \u0026#34;zo\u0026#34; 以及 \u0026#34;zoo\u0026#34;，但不能匹配 \u0026#34;z\u0026#34;。+ 等价于 {1,}。 ? #匹配前面的子表达式零次或一次。 #例如，\u0026#34;do(es)?\u0026#34; 可以匹配 \u0026#34;do\u0026#34; 、 \u0026#34;does\u0026#34; 中的 \u0026#34;does\u0026#34; 、 \u0026#34;doxy\u0026#34; 中的 \u0026#34;do\u0026#34; 。? 等价于 {0,1}。 {n} # n 是一个非负整数。匹配确定的 n 次。例如，\u0026#39;o{2}\u0026#39; 不能匹配 \u0026#34;Bob\u0026#34; 中的 \u0026#39;o\u0026#39;，但是能匹配 \u0026#34;food\u0026#34; 中的两个 o。 {n,} #n 是一个非负整数。至少匹配n 次。例如，\u0026#39;o{2,}\u0026#39; 不能匹配 \u0026#34;Bob\u0026#34; 中的 \u0026#39;o\u0026#39;，但能匹配 \u0026#34;foooood\u0026#34; 中的所有 o。\u0026#39;o{1,}\u0026#39; 等价于 \u0026#39;o+\u0026#39;。\u0026#39;o{0,}\u0026#39; 则等价于 \u0026#39;o*\u0026#39;。 {n,m} #m 和 n 均为非负整数，其中n \u0026lt;= m。最少匹配 n 次且最多匹配 m 次。 #例如，\u0026#34;o{1,3}\u0026#34; 将匹配 \u0026#34;fooooood\u0026#34; 中的前三个 o。\u0026#39;o{0,1}\u0026#39; 等价于 \u0026#39;o?\u0026#39;。请注意在逗号和两个数之间不能有空格。 5.定位符 定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。\n^ #匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \\n 或 \\r 之后的位置匹配。 $ #匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \\n 或 \\r 之前的位置匹配。 \\b #匹配一个字边界，即字与空格间的位置。 \\B #非字边界匹配。 ","date":"2020-09-12","permalink":"https://blog.singasoong.top/posts/regex%E7%AC%94%E8%AE%B0/","summary":"语法 1.普通字符 普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。","tags":["笔记"],"title":"Regex笔记"},{"categories":null,"contents":"当我们在启动spark集群work节点的的时候，每次都需要输入每个节点服务器的密码，这样无疑是很麻烦的。设置SSH免密后就可跳过密码输入的步骤。\n比如我们要进行本地连接远端服务器免密钥登陆，有如下几个步骤：\n在本地生成ssh密钥对 将公钥添加到远端服务器authorized_keys 文件 生成SSH公钥 过程中直接回车就好\nssh-keygen -t rsa -b 4096 -C \u0026#34;your email address\u0026#34; ... #最后会生成两个密钥文件 id_rsa # 私钥 id_rsa.pub # 公钥 将生成的 /root/.ssh 目录下的公钥文件复制到authorized_keys # 注意没有authorized_keys文件需要手动创建 echo \u0026#34;公钥信息\u0026#34; \u0026gt;\u0026gt; /root/.ssh/authorized_keys 测试 # root 对应登陆用户名 # ip 对于远端服务器IP # 22 对应端口 ssh root@ip -p 22 ","date":"2019-11-15","permalink":"https://blog.singasoong.top/posts/ssh-pass-free/","summary":"当我们在启动spark集群work节点的的时候，每次都需要输入每个节点服务器的密码，这样无疑是很麻烦的。设置SSH免密后就可跳过密码输入的步","tags":["ssh","linux"],"title":"ssh免密登录"},{"categories":null,"contents":"环境需要 java环境部署 spark环境部署 java环境部署（安装jdk） 参考：linux下java环境部署\nspark 环境部署 spark安装包下载 \u0026ndash;\u0026gt;spark官网下载地址\u0026lt;\u0026ndash;\n这里我下载的2.4.4版本:spark-2.4.4-bin-hadoop2.7.tgz\n解压缩 将下载的tgz包放到自定义路径下，我这里放到的 /opt 下 然后就是解压了，linux下的解压命令是\ntar -zxvf spark-2.4.4-bin-hadoop2.7.tgz 为了操作方便，将解压得到的spark-2.4.4-bin-hadoop2.7文件夹改名为spark-2.4.4：\nmv spark-2.4.4-bin-hadoop2.7 spark-2.4.4 配置环境变量 配置系统的环境变量：编辑 /etc/profile 文件，若执行命令提示没有 vim 时，用 vi 代替即可，也可以用如下命令安装即可\nyum -y install vim 编辑环境变量：\nvim /etc/profile 然后在文件的最后加上如下配置：\n#Spark export SPARK_HOME=/opt/spark-2.4.4 export PATH=$PATH:$SPARK_HOME/bin #Spark end 重新加载文件让其生效\nsource /etc/profile 然后键盘按下 “Esc” 键退出编辑模式，输入 :wq 保存即可\n重新加载文件让其生效\nsource /etc/profile 配置spark的配置文件之单机版 进入%SPARK_HOME%/conf路径，分别拷贝两个配置文件\ncd /opt/spark-2.4.4/conf # 分别拷贝两个配置文件 cp spark-env.sh.template spark-env.sh cp slaves.template slaves 编辑spark-env.sh文件：\nexport SPARK_MASTER_IP=192.168.1.210 export SPARK_MASTER_PORT=7077 编辑slaves文件：\nlocalhost 测试环境配置是否成功\ncd /opt/spark-2.4.4/bin/ ./run-example SparkPi 10 出现如下图所示字样即配置成功\n启动spark，bin目录下执行\n./spark-shell 配置spark的配置文件之单机版集群版 spark 的一些默认端口\n8080: master的webUI，sparkwebUI的端口 7077: 提交任务的端口 8081: worker的webUI的端口 18080: historyServer的webUI的端口 4040: application的webUI的端口 ","date":"2019-11-13","permalink":"https://blog.singasoong.top/posts/spark-deploy-singleton/","summary":"环境需要 java环境部署 spark环境部署 java环境部署（安装jdk） 参考：linux下java环境部署 spark 环境部署 spark安装包下载 \u0026n","tags":["spark","环境搭建"],"title":"spark 单机环境搭建"},{"categories":null,"contents":"最近接到一个任务：将spring cloud架构的系统部署到国产中间件：apusic(金蝶)中去。\n思路 由于之前完全没有接触过这个中间件，第一个想到的就是不用springboot 自带的tomcat，将服务器打成war包部署到外部tomcat中去。部署成功后再将他搬到apusic(当时想的是毕竟GC，操作应该大同小异)。\n于是就开始了下面的操作:\n项目是gradle构建\n更改build.gradle将Springboot 服务打包成war apply plugin: \u0026#39;java\u0026#39; apply plugin: \u0026#39;org.springframework.boot\u0026#39; apply plugin: \u0026#39;eclipse\u0026#39; apply plugin: \u0026#39;net.saliman.properties\u0026#39; apply plugin: \u0026#39;io.spring.dependency-management\u0026#39; apply plugin: \u0026#39;war\u0026#39; # 引入war插件 dependencies { ... # 由于用外部tomcat启动 去掉继承的tomcat providedRuntime \u0026#39;org.springframework.boot:spring-boot-starter-tomcat\u0026#39; ... } 新增一个启动配置类继承SpringBootServletInitializer 接口，重写configure方法 /** * @Author: hesong * @Describe: */ public class MCStartApplication extends SpringBootServletInitializer { @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) { return builder.sources(ManagementCenterApplication.class); } } ","date":"2019-09-07","permalink":"https://blog.singasoong.top/posts/war%E5%8C%85%E9%83%A8%E7%BD%B2spring-cloud%E5%B7%A5%E7%A8%8B/","summary":"最近接到一个任务：将spring cloud架构的系统部署到国产中间件：apusic(金蝶)中去。 思路 由于之前完全没有接触过这个中间件，第一个","tags":["spring boot","war包部署"],"title":"war包部署spring cloud 工程"},{"categories":null,"contents":"git 常用操作 stash git pull #down代码 git stash #备份 git stash save [\u0026lt;message\u0026gt;] #备份及添加备份信息 git stash pop #还原代码 branch git checkout -b abc #git创建分支abc git checkout master #切换到master分支 git branch -d \u0026#39;branchName\u0026#39; #删除本地分支 git status #查看分支中的代码目录 git add TowerLampDll.dll #添加待提交代码TowerLampDll.dll到git git status #查看提交的代码；（绿色表示准备提交的，红色表示可选择提交的） git reset HEAD \u0026lt;file\u0026gt; #恢复已add的文件为未提交的状态 git pull \u0026lt;origin\u0026gt; \u0026lt;activemq_local\u0026gt; #git更新远程分支代码到本地,\u0026lt;origin\u0026gt;:远程库名 \u0026lt;activemq_local\u0026gt;：待更新远程分支名 git branch -a | grep -v -E \u0026#39;master|remotes\u0026#39;|xargs git branch -d #批量删除本地分支 grep: -v 取反（not） -E 用分隔符连接(or) git remote show origin # 查看远程库的一些信息，及与本地分支的信息 git remote prune origin # 删除本地库中这些相比较远程库中已经不存在的分支 commit git status #查看更改的文件，红色表示有改动，绿色表示准备提交到本地仓库中文文件 git diff # 用于比较两次修改的差异 git commit\t#进入vi编辑器编辑注释， 编辑好后用:wq命令提交 git push -u origin abc # push本地仓库代码到远程\u0026#39;abc\u0026#39;分支 git log #可查看git提交版本编号 #然后在浏览器中进入git lab 提交merge请求 git config commit.template myTemplate.template\t#运行模板 # 修改提交信息 git commit --amend # 进入编辑器修改 git commit --amend \u0026#39;update information\u0026#39; # 直接更改为新输入的提交信息 restore git restore # git restore命令是撤销的意思，也就是把文件从缓存区撤销，回到未被追踪的状态。 revert git reset HEAD # 已经add 将文件回滚到上次add的状态 git checkout -- \u0026#39;fileName\u0026#39;#文件还未add到缓存队列 git checkout . # 回滚所有修改的文件 git checkout . \u0026amp;\u0026amp; git clean -df # 回滚所有修改、删除、新增的文件 cherry-pick git cherry-pick \u0026lt;commit No.\u0026gt; # commit编号 git cherry-pick No1..No2 # N1,N2两次commit编号 rebase git checkout -b testbranch # 切换到待rebase的分支（假设该分支已推到远程） git rebase master git rebase --continue # 解决冲突后继续rebase git rebase --skip # 跳过 git rebase --abort # 返回rebase前的状态 git push --force-with-lease origin feature # 将rebase后的代码同步到远程分支 merge git pull #更新代码 git checkout -b \u0026#39;newBranchName#新建一个本地分支 git merge \u0026#39;target\u0026#39; #merge target分支，target待合并的分支，git会自动merge部分代码，未能merge的需要手动merge git status #查看merge后的状态 for example： bms@bms MINGW64 /c/test (master) $ git pull Already up-to-date. bms@bms MINGW64 /c/test (master) $ git checkout -b activemq_local Switched to a new branch \u0026#39;activemq_local\u0026#39; bms@bms MINGW64 /c/test (activemq_local) $ git merge activemq Auto-merging test-commons/src/main/java/com/song/commons/model/NeClass.java Auto-merging test-commons/src/main/java/com/song/commons/model/ITProtocol.java Auto-merging test-collector/src/main/resources/connectors.xml CONFLICT (content): Merge conflict in test-collector/src/main/resources/connectors.xml Automatic merge failed; fix conflicts and then commit the result. bms@bms MINGW64 /c/test (activemq_local|MERGING) $ git status On branch activemq_local You have unmerged paths. (fix conflicts and run \u0026#34;git commit\u0026#34;) (use \u0026#34;git merge --abort\u0026#34; to abort the merge) Changes to be committed: modified: connectors/test-buildin-connectors/build.gradle new file: connectors/test-buildin-connectors/src/main/java/com/song/test/collector/connections/ActiveMQConnection.java new file: test-collector-data/src/main/java/com/song/test/networkentity/target/ActiveMQTarget.java new file: test-collector/src/main/resources/config/indicators/indicator.activemq.xml new file: test-collector/src/main/resources/config/query-templates/web-server/query.activemq.xml modified: test-commons/src/main/java/com/song/commons/model/ITProtocol.java modified: test-commons/src/main/java/com/song/commons/model/NeClass.java Unmerged paths: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to mark resolution) both modified: test-collector/src/main/resources/connectors.xml Changes not staged for commit: (use \u0026#34;git add/rm \u0026lt;file\u0026gt;...\u0026#34; to update what will be committed) (use \u0026#34;git checkout -- \u0026lt;file\u0026gt;...\u0026#34; to discard changes in working directory) # 此时在ide中将both modified (冲突文件)解决 # 然后git add . # git merge --continue . . . git删除用户名密码 # tortoriseGit --\u0026gt; settings --\u0026gt; GIt--\u0026gt; Edit systemwide gitconfig 打开文件 # 或者 直接打开文件：GIT_HOME/mingw64/etc/gitconfig 删除其中credential一项 [http] sslCAInfo = D:/Program Files/Git/mingw64/ssl/certs/ca-bundle.crt sslBackend = openssl [diff \u0026#34;astextplain\u0026#34;] textconv = astextplain [filter \u0026#34;lfs\u0026#34;] clean = git-lfs clean -- %f smudge = git-lfs smudge -- %f process = git-lfs filter-process required = true [credential] helper = manager git status 不能显示中文 问题描述：\n\u0026gt; git status Untracked files: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to include in what will be committed) \u0026#34;content/posts/Windows\\347\\254\\224\\350\\256\\260.md\u0026#34; \u0026#34;content/posts/gradle\\347\\254\\224\\350\\256\\260.md\u0026#34; 原因： 默认情况下，中文文件名在工作区状态输出，中文不能正确显示，而是显示为八进制的字符编码 解决办法： 将git配置文件core.quotepath项设置未false。 quotepath表示引用路径，加上--global 表示全局 git config --global core.quotepath false git 不能使用正则（仅适用于终端使用了zsh的情况） 问题描述：\n# 使用正则匹配不能添加文件 \u0026gt; git add *.java 解决方法：在.zshrc文件中添加setout nonomatch即可\necho \u0026#34;setout nonomatch\u0026#34; \u0026gt;\u0026gt; ~/.zshrc source ~/.zshrc git 修改远程Repo Url # 方式1 -- 直接设置 适用于新的repo 之前没有设置过url git remote add origin # 方式2 -- 先删除 在设置 git remote rm origin git remote add origin [url] ","date":"2019-09-03","permalink":"https://blog.singasoong.top/posts/git%E4%BD%BF%E7%94%A8/","summary":"git 常用操作 stash git pull #down代码 git stash #备份 git stash save [\u0026lt;message\u0026gt;] #备份及添加备份信息 git stash pop #还原代码 branch git checkout -b abc #git创建分支abc git checkout master #切换到maste","tags":["git","笔记"],"title":"git使用"},{"categories":null,"contents":"mongoDB安装 参照：https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/\n配置yum管理包 在路径/etc/yum.repos.d/下创建文件mongodb-org-3.4.repo\n[mongodb-org-3.4] name=MongoDB Repository baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.4/x86_64/ gpgcheck=1 enabled=1 gpgkey=https://www.mongodb.org/static/pgp/server-3.4.asc 安装mongo yum install -y mongodb-org mongo相关操作\n创建用户\nmongo //启动Mongo shell命令 use admin //切换到admin数据库 db.createUser({user:\u0026#34;root\u0026#34;,pwd:\u0026#34;123456\u0026#34;,roles:[\u0026#34;root\u0026#34;]}) //创建用户 db.auth(\u0026#34;root\u0026#34;,\u0026#34;123456\u0026#34;) //验证用户创建是否成功 高可用性的mongo集群 参照：http://www.lanceyan.com/tech/arch/mongodb_shard1.html\n三台服务器分配 按表格分别在各服务器进行目录创建：\n192.168.1.91 服务 端口 日志路径 数据路径 mongos 20001 mkdir -p /data/mongodbtest/mongos/log \u0026ndash; Config server 21001 mkdir -p /data/mongodbtest/config/log mkdir -p /data/mongodbtest/config/data Shard server1主节点 22001 mkdir -p /data/mongodbtest/shard1/log mkdir -p /data/mongodbtest/shard1/data Shard server2副本 22002 mkdir -p /data/mongodbtest/shard2/log mkdir -p /data/mongodbtest/shard2/data Shard server3仲裁 22003 mkdir -p /data/mongodbtest/shard3/log mkdir -p /data/mongodbtest/shard3/data 192.168.1.92 服务 端口 日志路径 数据路径 mongos 20001 mkdir -p /data/mongodbtest/mongos/log \u0026ndash; Config server 21001 mkdir -p /data/mongodbtest/config/log mkdir -p /data/mongodbtest/config/data Shard server1仲裁 22001 mkdir -p /data/mongodbtest/shard1/log mkdir -p /data/mongodbtest/shard1/data Shard server2主节点 22002 mkdir -p /data/mongodbtest/shard2/log mkdir -p /data/mongodbtest/shard2/data Shard server3副本 22003 mkdir -p /data/mongodbtest/shard3/log mkdir -p /data/mongodbtest/shard3/data 192.168.1.93 服务 端口 日志路径 数据路径 mongos 20001 mkdir -p /data/mongodbtest/mongos/log \u0026ndash; Config server 21001 mkdir -p /data/mongodbtest/config/log mkdir -p /data/mongodbtest/config/data Shard server1副本 22001 mkdir -p /data/mongodbtest/shard1/log mkdir -p /data/mongodbtest/shard1/data Shard server2仲裁 22002 mkdir -p /data/mongodbtest/shard2/log mkdir -p /data/mongodbtest/shard2/data Shard server3主节点 22003 mkdir -p /data/mongodbtest/shard3/log mkdir -p /data/mongodbtest/shard3/data 启动Config server 启动Config server\n分别配置三台config服务的配置文件，分别在对应config server的conf目录下(/data/mongodbtest/config/conf/)创建mongo_config.conf文件\nstorage: dbPath: /data/mongodbtest/config/data indexBuildRetry: true systemLog: destination: file path: /data/mongodbtest/config/log/config.log net: port: 21001 sharding: clusterRole: configsvr replication: replSetName: docdetection processManagement: fork: true 通过配置文件分别启动config配置服务\nmongod --config /data/mongodbtest/config/conf/mongo_config.conf 初始化config复本集\n#设置config副本集，登录其中一个config服务器 /usr/bin/mongo 127.0.0.1:21001 #使用admin数据库 use admin #定义副本集配置 config ={_id:\u0026#39;docdetection\u0026#39;,members:[ {_id:0,host:\u0026#39;192.168.1.91:21001\u0026#39;,priority:3}, {_id:1,host:\u0026#39;192.168.1.92:21001\u0026#39;,priority:2}, {_id:2,host:\u0026#39;192.168.1.93:21001\u0026#39;,priority:1} ] } #初始化副本集配置 rs.initiate(config); #初始化结束（注意关闭各服务器防火墙） { \u0026#34;ok\u0026#34; : 1 } #查看状态 rs.status() 启动Shard server（分片服务） 启动各分片服务\n分别到各服务器上各shard的conf目录下建文件mongo_config.conf。eg:192.168.1.91\n# shard1 storage: dbPath: /data/mongodbtest/shard1/data indexBuildRetry: true systemLog: destination: file path: /data/mongodbtest/shard1/log/shard1.log net: port: 22001 sharding: clusterRole: shardsvr replication: replSetName: shard1 processManagement: fork: true # shard2 storage: dbPath: /data/mongodbtest/shard2/data indexBuildRetry: true systemLog: destination: file path: /data/mongodbtest/shard2/log/shard2.log net: port: 22002 sharding: clusterRole: shardsvr replication: replSetName: shard2 processManagement: fork: true # shard3 storage: dbPath: /data/mongodbtest/shard3/data indexBuildRetry: true systemLog: destination: file path: /data/mongodbtest/shard3/log/shard3.log net: port: 22003 sharding: clusterRole: shardsvr replication: replSetName: shard3 processManagement: fork: true 通过配置文件分别启动shard分片服务(3*3=9个)\nmongod --config /data/mongodbtest/shard1/conf/mongo_config.conf mongod --config /data/mongodbtest/shard2/conf/mongo_config.conf mongod --config /data/mongodbtest/shard3/conf/mongo_config.conf 初始化各分片服务器副本集\n设置第一个分片副本集:shard1（保证各副本已启动）注：priority 的值决定主（值大）从关系；arbiterOnly 指定仲裁节点\n#设置第一个分片副本集，登录其中一个分片服务器 /usr/bin/mongo 127.0.0.1:22001 #使用admin数据库 use admin #定义副本集配置 config = { _id:\u0026#34;shard1\u0026#34;, members:[ {_id:0,host:\u0026#34;192.168.1.91:22001\u0026#34;,priority:2}, {_id:1,host:\u0026#34;192.168.1.92:22001\u0026#34;,arbiterOnly:true}, {_id:2,host:\u0026#34;192.168.1.93:22001\u0026#34;,priority:1} ] } #初始化副本集配置 rs.initiate(config); 设置第二个分片副本集：shard2\n#设置第二个分片副本集，登录其中一个分片服务器 /usr/bin/mongo 127.0.0.1:22002 #使用admin数据库 use admin #定义副本集配置 config = { _id:\u0026#34;shard2\u0026#34;, members:[ {_id:0,host:\u0026#34;192.168.1.91:22002\u0026#34;,priority:1}, {_id:1,host:\u0026#34;192.168.1.92:22002\u0026#34;,priority:2}, {_id:2,host:\u0026#34;192.168.1.93:22002\u0026#34;,arbiterOnly:true} ] } #初始化副本集配置 rs.initiate(config); 设置第三个分片副本集：shard3\n#设置第三个分片副本集，登录其中一个分片服务器 /usr/bin/mongo 127.0.0.1:22003 #使用admin数据库 use admin #定义副本集配置 config = { _id:\u0026#34;shard3\u0026#34;, members:[ {_id:0,host:\u0026#34;192.168.1.91:22003\u0026#34;,arbiterOnly:true}, {_id:1,host:\u0026#34;192.168.1.92:22003\u0026#34;,priority:1}, {_id:2,host:\u0026#34;192.168.1.93:22003\u0026#34;,priority:2} ] } #初始化副本集配置 rs.initiate(config); 启动mongos路由服务 配置mongos服务的配置文件，对应的conf目录下创建mongo_config.conf文件 systemLog: destination: file path: /data/mongodbtest/mongos/log/mongos.log net: port: 20001 sharding: configDB: docdetection/192.168.1.91:21001,192.168.1.92:21001,192.168.1.93:21001 processManagement: fork: true 通过配置文件分别启动config配置服务 mongos --config /data/mongodbtest/mongos/conf/mongo_config.conf 整合配置、路由、分片服务器 整合配置服务器、路由服务器，各个分片服务器\n整合配置、路由、分片服务器\n目前搭建了mongodb配置服务器、路由服务器，各个分片服务器，不过应用程序连接到 mongos 路由服务器并不能使用分片机制，还需要在程序里设置分片配置，让分片生效。分别连接三个mongos，添加分片副本集。\n#设置分片配置，登录mongos路由服务器 /usr/bin/mongo 127.0.0.1:20001 #使用admin数据库 use admin #串联路由服务器与分片副本集1 sh.addShard(\u0026#34;shard1/192.168.1.91:22001,192.168.1.92:22001,192.168.1.93:22001\u0026#34;) #串联路由服务器与分片副本集2 sh.addShard(\u0026#34;shard2/192.168.1.91:22002,192.168.1.92:22002,192.168.1.93:22002\u0026#34;) #串联路由服务器与分片副本集3 sh.addShard(\u0026#34;shard3/192.168.1.91:22003,192.168.1.92:22003,192.168.1.93:22003\u0026#34;) 添加创建用户\n集群管理员账号（mongos和配置服务器的集群管理员用户是可以通用的）\n#以下是创建集群管理员用户步骤（连接其中一台Mongos服务上执行即可） #登录mongos路由服务器 /usr/bin/mongo 127.0.0.1:20001 #使用admin数据库 use admin #创建账号及指定权限 db.createUser({ user: \u0026#34;adminRoot\u0026#34;, pwd: \u0026#34;adminbear\u0026#34;, roles: [ { role: \u0026#34;root\u0026#34;, db: \u0026#34;admin\u0026#34; }, { role: \u0026#34;clusterAdmin\u0026#34;, db: \u0026#34;admin\u0026#34; }, { role: \u0026#34;userAdmin\u0026#34;, db: \u0026#34;admin\u0026#34; } ] }); 数据库用户\n#登录mongos路由服务器 /usr/bin/mongo 127.0.0.1:20001 #以下是为数据库名mongoTest，创建数据库用户 use mongoTest; db.createUser({ user: \u0026#34;mongoTestUser\u0026#34;, pwd: \u0026#34;bear\u0026#34;, roles: [ { role: \u0026#34;readWrite\u0026#34;, db: \u0026#34; mongoTest\u0026#34; } ] } ); 目前配置服务、路由服务、分片服务、副本集服务都已经串联起来了，但我们的目的是希望插入数据，数据能够自动分片。连接在mongos上，准备让指定的数据库、指定的集合分片生效。\n创建数据库，让指定数据库分片生效\n建库、表、指定应用分片的库\n#登录mongos路由服务器 /usr/bin/mongo 127.0.0.1:20001 #创建或者使用mongoTest数据库 use mongoTest; #创建mongoTest数据库中的集合 db.createCollection(\u0026#34;table1\u0026#34;) #新建集合：table1 · · · #切换到admin数据库 use admin #指定testdb分片生效，mongoTest为数据库名称 db.runCommand( { enablesharding :\u0026#34;mongoTest\u0026#34;}); 指定分片的表。两种分片方式： Hashed Shard Key与Ranged Shard Key\nHashed Shard Key：它采用字段的索引哈希值作为 shard key 的取值，这样做可以保证数据的均匀分布。在 mongos 和各个 shard 集群之间存在一个哈希值计算方法，所有的数据在迁移时都是根据这个方法来计算数据应当被迁移到什么地方。当 mongos 接收到一条语句时，通常他会把这条语句广播到所有的 shard 上去执行。\nRanged Shard Key: 根据 shard key 的取值，它把数据切分成连续的几个区间。取值相近的纪录会放进同一个 shard 服务器。好处是查询连续取值纪录时，查询效率可以得到保证。当数据库查询语句发送到 mongos 中时，mongos 会很快的找到目标 shard，而且不需要将语句发送到所有的 shard 上，一般只需要少量的 shard 就可以完成查询操作。缺点是不能保证数据的平均分配，在数据插入和修改时会产生比较严重的性能瓶颈\n#指定数据库里需要分片的集合和片键，table1为mongoTest数据库中集合名称 db.runCommand({shardcollection:\u0026#34;mongoTest.table1\u0026#34;,key:{\u0026#34;ZZJGDM\u0026#34;: \u0026#34;hashed\u0026#34;}}) //Hashed Shard Key db.runCommand({shardcollection:\u0026#34;mongoTest.table1\u0026#34;,key:{_id:1}})// Ranged Shard Key ","date":"2019-06-25","permalink":"https://blog.singasoong.top/posts/mongo%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/","summary":"mongoDB安装 参照：https://docs.mongodb.com/manual/tutorial/install-mongodb-o","tags":["mongo集群","部署"],"title":"高可用性的mongo集群搭建"},{"categories":null,"contents":"","date":"2019-05-02","permalink":"https://blog.singasoong.top/search/","summary":"","tags":null,"title":"Search"},{"categories":null,"contents":"1. linux忘记root密码 解决办法\n2. java环境变量配置 1.编辑系统变量文件：vi /etc/profile\nexport JAVA_HOME=/usr/java/jdk1.8.0_151 export JRE_HOME=$JAVA_HOME/jre export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib export PATH=$JAVA_HOME/bin:$PATH 3.进程 netstat -tunlp |grep 22 //查看22端口使用情况 4.tar解、压缩 1.tar\n-c: 建立压缩档案 -x：解压 -t：查看内容 -r：向压缩归档文件末尾追加文件 -u：更新原压缩包中的文件 2.这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。\n-z：有gzip属性的 -j：有bz2属性的 -Z：有compress属性的 -v：显示所有过程 -O：将文件解开到标准输出 3.下面的参数-f是必须的\n# -f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。 # 这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。 tar -cf all.tar *.jpg # 这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。 tar -rf all.tar *.gif # 这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。 tar -uf all.tar logo.gif # 这条命令是列出all.tar包中所有文件，-t是列出文件的意思 tar -tf all.tar # 这条命令是解出all.tar包中所有文件，-x是解开的意思 tar -xf all.tar 4.压缩\ntar -cvf jpg.tar *.jpg //将目录里所有jpg文件打包成tar.jpg tar -czf jpg.tar.gz *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz tar -cjf jpg.tar.bz2 *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2 tar -cZf jpg.tar.Z *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z rar a jpg.rar *.jpg //rar格式的压缩，需要先下载rar for linux zip jpg.zip *.jpg //zip格式的压缩，需要先下载zip for linux 5.解压\ntar -xvf file.tar //解压 tar包 tar -xzvf file.tar.gz //解压tar.gz tar -xjvf file.tar.bz2 //解压 tar.bz2 tar -xZvf file.tar.Z //解压tar.Z unrar e file.rar //解压rar unzip file.zip //解压zip 6.总结\n1、*.tar 用 tar -xvf 解压 2、*.gz 用 gzip -d或者gunzip 解压 3、*.tar.gz和*.tgz 用 tar -xzf 解压 4、*.bz2 用 bzip2 -d或者用bunzip2 解压 5、*.tar.bz2用tar -xjf 解压 6、*.Z 用 uncompress 解压 7、*.tar.Z 用tar -xZf 解压 8、*.rar 用 unrar e解压 9、*.zip 用 unzip 解压 5. linux下动态查看日志 tail -f fileName 6. 服务自启动 [root@localhost ~]chkconfig smb on #or [root@localhost ~]# vi /etc/rc.local #!/bin/sh # # This script will be executed *after* all the other init scripts. # You can put your own initialization stuff in here if you don\u0026#39;t # want to do the full Sys V style init stuff. service smb start 7.网卡配置 ifdown eth3 \u0026amp;\u0026amp; ifup eth3 service network restart 8.vi编辑器の操作 a //在当前字符后添加文本 A //在行末添加文本 i //在当前字符前插入文本 I //在当前行首插入文本 o //在当前行后面插入一空行 O //在当前行前面插入一空行 /字符串 //往下查找字符串 n //往下跳到下一个匹配位置 N //往上跳到下一个匹配位置 ?字符串 //往上匹配字符串（与\u0026#39;/字符串\u0026#39;操作相反） p //粘贴文本操作，用于将缓存区的内容粘贴到当前光标所在位置的下方 P //粘贴文本操作，用于将缓存区的内容粘贴到当前光标所在位置的上方 Ctrl+u //向文件首翻半屏 Ctrl+d //向文件尾翻半屏 Ctrl+f //向文件尾翻一屏 Ctrl+b //向文件首翻一屏； Esc //从编辑模式切换到命令模式； ZZ //命令模式下保存当前文件所做的修改后退出vi； :行号 //光标跳转到指定行的行首； :$ //光标跳转到最后一行的行首； x或X //删除一个字符，x删除光标后的，而X删除光标前的； D //删除从当前光标到光标所在行尾的全部字符； dd //删除光标行正行内容； ndd //删除当前行及其后n-1行； nyy //当前行及其下n行的内容保存到寄存器？中，其中？为一个字母，n为一个数字； gg //让光标移到首行，在vim才有效，vi中无效 G //光标移到最后一行 V //是进入Visual(可视）模式 dG //全部删除 ggyG //全部复制 ggVG //全选 d //删除选中 y //复制选中内容到0号寄存器 \u0026#34;+y //复制选中内容到＋寄存器，也就是系统的剪贴板，供其他程序用 gg\u0026#34;+yG //要复制到别的地方，用 \u0026#34;+y 来复制 9.时间戳 date //获取当前系统时间 date -d \u0026#39;@1526973325\u0026#39; //将时间戳转换为时间 10.文件比较之\u0026rsquo;diff' 11. linux 从一个IP机器跳转至另一IP机器: ssh ssh – OpenSSH remote login client\n$ man ssh NAME ssh – OpenSSH remote login client SYNOPSIS ssh [-46AaCfGgKkMNnqsTtVvXxYy] [-B bind_interface] [-b bind_address] [-c cipher_spec] [-D [bind_address:]port] [-E log_file] [-e escape_char] [-F configfile] [-I pkcs11] [-i identity_file] [-J destination] [-L address] [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port] [-Q query_option] [-R address] [-S ctl_path] [-W host:port] [-w local_tun[:remote_tun]] destination [command [argument ...]] # 示例 ssh username@IP password： 12. linux系统间的文件（目录）传输 命令：scp 选项 参数 scp \u0026#34;文件名\u0026#34; \u0026#34;用户名@计算机IP或者计算机名称:远程路径\u0026#34; //将本地文件拷贝到远程 scp -r \u0026#34;目录名\u0026#34; \u0026#34;用户名@计算机IP或者计算机名称:远程路径\u0026#34; //将本地目录拷贝到远程 scp \u0026#34;用户名@计算机IP或者计算机名称:文件名\u0026#34; \u0026#34;本地路径\u0026#34; //从远程将文件拷回本地 scp -r \u0026#34;用户名@计算机IP或者计算机名称:目录名\u0026#34; \u0026#34;本地路径\u0026#34; //从远程将目录拷回本地 -a\t尽可能将档案状态、权限等资料都照原状予以复制 -r\t若 source 中含有目录名，则将目录下之档案亦皆依序拷贝至目的地 -f\t若目的地已经有相同档名的档案存在，则在复制前先予以删除再行复制 -v\t和大多数 linux 命令中的 -v 意思一样 , 用来显示进度 . 可以用来查看连接 , 认证 , 或是配置错误 -C\t使能压缩选项 -P\t选择端口 . 注意 -p 已经被 rcp 使用 -4\t强行使用 IPV4 地址 -6\t强行使用 IPV6 地址 13. linux centos7 关于防火墙操作 # 在root权限下查看防火墙状态。 systemctl status firewalld # 临时关闭防火墙命令。重启电脑后，防火墙自动起来。 systemctl stop firewalld # 永久关闭防火墙命令。重启后，防火墙不会自动启动。 systemctl disable firewalld # 打开防火墙命令。 systemctl enable firewalld ","date":"2019-01-30","permalink":"https://blog.singasoong.top/posts/linux/","summary":"1. linux忘记root密码 解决办法 2. java环境变量配置 1.编辑系统变量文件：vi /etc/profile export JAVA_HOME=/usr/java/jdk1.8.0_151 export JRE_HOME=$JAVA_HOME/jre export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib export PATH=$JAVA_HOME/bin:$PATH 3.进程 netstat -tunlp |grep 22 //查看22端口使用情","tags":["linux"],"title":"linux的一些零星记录"},{"categories":null,"contents":"下载JDK安装包 \u0026ndash;\u0026gt;jdk下载官网\u0026lt;\u0026ndash;\n\u0026ndash;\u0026gt;jdk历史版本下载\u0026lt;\u0026ndash;\n根据自己的系统版本下载*.tar.gz结尾的压缩包， 我这里下载的是 jdk-8u151-linux-i586.tar.gz 安装包\n解压缩 将下载的安装包放到自定义路径下，我这里放到的 /opt 下 然后就是解压了，linux下的解压命令是\ntar -zxvf jdk-8u151-linux-i586.tar.gz 配置环境变量 配置系统的环境变量：编辑 vim /etc/profile 文件，若执行命令提示没有 vim 时，用 vi 代替即可，也可以用如下命令安装即可\nyum -y install vim 编辑环境变量：\nvim /etc/profile 然后在文件的最后加上如下配置：\n#java export JAVA_HOME=/opt/jdk1.8.0_151 export JRE_HOME=$JAVA_HOME/jre export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib export PATH=$JAVA_HOME/bin:$PATH #java end 重新加载文件让其生效\nsource /etc/profile 检查是否配置成功 java -verison 如下显示即安装成功\n","date":"2019-01-13","permalink":"https://blog.singasoong.top/posts/java-deployment-under-linux/","summary":"下载JDK安装包 \u0026ndash;\u0026gt;jdk下载官网\u0026lt;\u0026ndash; \u0026ndash;\u0026gt;jdk历史版本下载\u0026lt;\u0026ndash; 根据","tags":["java","环境搭建"],"title":"部署｜linux下java环境部署"},{"categories":null,"contents":"1.安装 sudo yum -y install samba 2.配置 /etc/samba/smb.conf eg: [global] workgroup = Administrators netblos name = server string = Linux Samba Server TestServer security = share display charset=UTF-8 unix charset=UTF-8 dos charset=UTF-8 [share] #====\u0026gt;windows下显示的共享文件夹名字：share path = /opt writeable = yes browseable = yes guest ok = yes 3.启动服务 service smb start 3. 开机自启动 [root@localhost ~]$ vi /etc/rc.local #!/bin/sh # # This script will be executed *after* all the other init scripts. # You can put your own initialization stuff in here if you don\u0026#39;t # want to do the full Sys V style init stuff. service smb start 遇到的问题 SELinux linux安全策略 # 1. 关闭SELinux vim /etc/sysconfig/selinux vim /etc/selinux/config ##把SELINUX=enforcing 改为 SELINUX=disabled ##临时关闭SELinux setenforce 0 防火墙导致samba连接不了的问题 #2. 关闭防火墙 ## 关闭iptables /etc/init.d/iptables stop ## 永久关闭 chkconfig iptables off ## 检查 chkconfig --list iptables 文件夹权限 #3. 检查文件夹权限 chmod 777 /opt ","date":"2019-01-10","permalink":"https://blog.singasoong.top/posts/samba%E4%BD%BF%E7%94%A8/","summary":"1.安装 sudo yum -y install samba 2.配置 /etc/samba/smb.conf eg: [global] workgroup = Administrators netblos name = server string = Linux Samba Server TestServer security = share display charset=UTF-8 unix charset=UTF-8 dos charset=UTF-8 [share] #====\u0026gt;windows下显示的共享文件夹名字：sha","tags":["共享文件夹","linux"],"title":"Samba在linux上的使用"},{"categories":null,"contents":"获取本机ip 通过NetworkInterface获取\nString ip = request.getRemoteAddr(); System.out.println(\u0026#34;---\u0026gt;\u0026#34;+ip); Enumeration\u0026lt;NetworkInterface\u0026gt; n = NetworkInterface.getNetworkInterfaces(); for (; n.hasMoreElements();) { NetworkInterface e = n.nextElement(); System.out.println(\u0026#34;Interface: \u0026#34; + e.getName()); Enumeration\u0026lt;InetAddress\u0026gt; a = e.getInetAddresses(); for (; a.hasMoreElements();) { InetAddress addr = a.nextElement(); if (!addr.isLinkLocalAddress() \u0026amp;\u0026amp; !addr.isLoopbackAddress() \u0026amp;\u0026amp; addr instanceof Inet4Address) { System.out.println(\u0026#34; \u0026#34; + addr.getHostAddress()); } } } 根据网卡获取ip 根据物理网卡获取本机IP\n/** * 根据网卡获得IP地址 * @return * @throws SocketException * @throws UnknownHostException */ public static String getIpAdd() throws SocketException, UnknownHostException { String LOCAL_HOST_IP = \u0026#34;127.0.0.1\u0026#34;; String ip = LOCAL_HOST_IP; for (Enumeration\u0026lt;NetworkInterface\u0026gt; en = NetworkInterface.getNetworkInterfaces(); en.hasMoreElements();) { NetworkInterface intf = en.nextElement(); String name = intf.getName(); if (!name.contains(\u0026#34;docker\u0026#34;) \u0026amp;\u0026amp; !name.contains(\u0026#34;lo\u0026#34;)) { for (Enumeration\u0026lt;InetAddress\u0026gt; enumIpAddr = intf.getInetAddresses(); enumIpAddr.hasMoreElements();) { // 获得IP InetAddress inetAddress = enumIpAddr.nextElement(); if (!inetAddress.isLoopbackAddress()) { String ipaddress = inetAddress.getHostAddress().toString(); if (!ipaddress.contains(\u0026#34;::\u0026#34;) \u0026amp;\u0026amp; !ipaddress.contains(\u0026#34;0:0:\u0026#34;) \u0026amp;\u0026amp; !ipaddress.contains(\u0026#34;fe80\u0026#34;)) { logger.debug(\u0026#34;IP:\u0026#34; + ipaddress); if (!LOCAL_HOST_IP.equals(ipaddress)) { return ipaddress; } } } } } } return ip; } IP转换为int public static int toIp(String ipAddress) { String[] address = StringUtils.split(ipAddress, \u0026#34;.\u0026#34;); if (address.length != 4) { StringBuilder builder = new StringBuilder(); builder.append(\u0026#34;Invalid IP format \\\u0026#34;\u0026#34;).append(ipAddress).append(\u0026#34;\\\u0026#34;, should be XXX.XXX.XXX.XXX\u0026#34;); throw new IllegalArgumentException(builder.toString()); } else { int result = 0; for (int i = 0; i \u0026lt; address.length; ++i) { int segment = Integer.parseInt(address[i]); if (segment \u0026lt; 0 || segment \u0026gt;= 256) { StringBuilder builder = new StringBuilder(); builder.append(\u0026#34;Invalid IP format \\\u0026#34;\u0026#34;).append(ipAddress).append(\u0026#34;\\\u0026#34;\u0026#34;); throw new IllegalArgumentException(builder.toString()); } result = result \u0026lt;\u0026lt; 8 | segment; } return result; } } ","date":"2018-10-31","permalink":"https://blog.singasoong.top/posts/ip%E8%8E%B7%E5%8F%96/","summary":"获取本机ip 通过NetworkInterface获取 String ip = request.getRemoteAddr(); System.out.println(\u0026#34;---\u0026gt;\u0026#34;+ip); Enumeration\u0026lt;NetworkInterface\u0026gt; n = NetworkInterface.getNetworkInterfaces(); for (; n.hasMoreElements();) { NetworkInterface e = n.nextElement(); System.out.println(\u0026#34;Interface: \u0026#34; + e.getName()); Enumeration\u0026lt;InetAddress\u0026gt; a = e.getInetAddresses(); for (; a.hasMoreElements();) { InetAddress addr = a.nextElement(); if (!addr.isLinkLocalAddress() \u0026amp;\u0026amp; !addr.isLoopbackAddress() \u0026amp;\u0026amp; addr instanceof Inet4Address) { System.out.println(\u0026#34; \u0026#34;","tags":["笔记"],"title":"笔记｜IP 获取"},{"categories":null,"contents":"gradle 国内镜像配置 单项目 对单个项目生效，在项目中的build.gradle修改内容\nbuildscript { repositories { maven { url \u0026#39;http://maven.aliyun.com/nexus/content/groups/public/\u0026#39; } maven{ url \u0026#39;http://maven.aliyun.com/nexus/content/repositories/jcenter\u0026#39;} } dependencies { classpath \u0026#39;com.android.tools.build:gradle:2.2.3\u0026#39; // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files } } allprojects { repositories { maven { url \u0026#39;http://maven.aliyun.com/nexus/content/groups/public/\u0026#39; } maven{ url \u0026#39;http://maven.aliyun.com/nexus/content/repositories/jcenter\u0026#39;} } } 全局 对所有项目生效，在${USER_HOME}/.gradle/下创建init.gradle文件\nallprojects{ repositories { def ALIYUN_REPOSITORY_URL = \u0026#39;http://maven.aliyun.com/nexus/content/groups/public\u0026#39; def ALIYUN_JCENTER_URL = \u0026#39;http://maven.aliyun.com/nexus/content/repositories/jcenter\u0026#39; all { ArtifactRepository repo -\u0026gt; if(repo instanceof MavenArtifactRepository){ def url = repo.url.toString() if (url.startsWith(\u0026#39;https://repo1.maven.org/maven2\u0026#39;)) { project.logger.lifecycle \u0026#34;Repository ${repo.url} replaced by $ALIYUN_REPOSITORY_URL.\u0026#34; remove repo } if (url.startsWith(\u0026#39;https://jcenter.bintray.com/\u0026#39;)) { project.logger.lifecycle \u0026#34;Repository ${repo.url} replaced by $ALIYUN_JCENTER_URL.\u0026#34; remove repo } } } maven { url ALIYUN_REPOSITORY_URL url ALIYUN_JCENTER_URL } } } 相关命令 gradle命令查看目录树 如果存在依赖冲突，在默认情况下，Gradle会选择最新版本，这和Maven是不同的，Maven会选择离依赖树最近的版本。当然，我们可以通过设置Configuration的resolutionStrategy来重新设置依赖冲突的处理规则，对此本文将不予讲解。\n# gradle 查看目录树 gradle dependencies # gradle 输出目录树到text.txt文件 gradle dependencies \u0026gt; text.txt #gradlew 查看目录树输出到文件 gradlew -q :dependencies \u0026gt; text.txt gradle脚本 变量要用双引号 如：version: \u0026ldquo;$springBootVersion\u0026rdquo;\next { springBootVersion = \u0026#34;2.0.4.RELEASE\u0026#34; fastJsonVersion = \u0026#34;1.2.35\u0026#34; druidVersion = \u0026#34;1.0.26\u0026#34; bootRedisVersion = \u0026#34;2.0.4.RELEASE\u0026#34; } dependencies { //compile(\u0026#34;org.springframework.boot:spring-boot-starter-web\u0026#34;) //testCompile(\u0026#39;org.springframework.boot:spring-boot-starter-test\u0026#39;) testCompile group: \u0026#39;org.springframework.boot\u0026#39;, name: \u0026#39;spring-boot-starter-test\u0026#39;, version: \u0026#34;$springBootVersion\u0026#34; compile group: \u0026#39;org.springframework.boot\u0026#39;, name: \u0026#39;spring-boot-starter-web\u0026#39;, version: \u0026#34;$springBootVersion\u0026#34; // This dependency is exported to consumers, that is to say found on their compile classpath. api \u0026#39;org.apache.commons:commons-math3:3.6.1\u0026#39; // This dependency is used internally, and not exposed to consumers on their own compile classpath. implementation \u0026#39;com.google.guava:guava:23.0\u0026#39; // Use JUnit test framework //testImplementation \u0026#39;junit:junit:4.12\u0026#39; testCompile group: \u0026#39;junit\u0026#39;, name: \u0026#39;junit\u0026#39;, version: \u0026#39;4.12\u0026#39; compile group: \u0026#39;org.postgresql\u0026#39;, name: \u0026#39;postgresql\u0026#39;, version: \u0026#39;9.4.1212\u0026#39; compile(\u0026#34;org.springframework.boot:spring-boot-starter-data-jpa:$springBootVersion\u0026#34;){ exclude (module: \u0026#34;xml-apis\u0026#34;) } compile group: \u0026#39;org.projectlombok\u0026#39;, name: \u0026#39;lombok\u0026#39;, version: \u0026#39;1.16.20\u0026#39; } ","date":"2018-08-26","permalink":"https://blog.singasoong.top/posts/gradle%E7%AC%94%E8%AE%B0/","summary":"gradle 国内镜像配置 单项目 对单个项目生效，在项目中的build.gradle修改内容 buildscript { repositories { maven { url \u0026#39;http://maven.aliyun.com/nexus/content/groups/public/\u0026#39; } maven{ url \u0026#39;http://maven.aliyun.com/nexus/content/repositories/jcenter\u0026#39;} } dependencies { classpath \u0026#39;com.android.tools.build:gradle:2.2.3\u0026#39; // NOTE: Do not place your application dependencies here; they belong // in the","tags":["笔记"],"title":"笔记｜Gradle笔记"},{"categories":null,"contents":"Windows关闭/开启管理员用户 # 管理员权限进入cmd net user administrator /active:tes // 开启 net user administrator /active:no // 关闭 Windows批处理（.bat） .bat脚本示例 @echo off rem 准备运行uxdb cd \u0026#34;D:\\Program Files\\UXDB\\dbsql\\bin\u0026#34; d: start uxdbStart.bat rem 准备运行redis cd \u0026#34;C:\\Program Files\\Redis\\\u0026#34; c: start redisStart.bat rem 准备运行activemq cd C: cd C:\\Users\\bms\\Desktop\\apache\\apache-activemq-5.10.0\\bin\\ start activeMQStart.bat Note 切换盘符： # 同一盘符可以随意切换 C:\\Users\\bms\u0026gt;cd \u0026#34;C:\\Program Files\\Redis\u0026#34; #若当前盘符中有空格，需要将盘符路径用“”引起来，否则会出错 # 不同盘符的切换（比如当前在C盘） C:\\Users\\bms\u0026gt;cd \u0026#34;D:\\Program Files\\UXDB\\dbsql\\bin\u0026#34; C:\\Users\\bms\u0026gt; #盘符并没有切换 C:\\Users\\bms\u0026gt;d： #此时再输入要切换的盘符名并以：结束 D:\\Program Files\\DB\\dbsql\\bin\u0026gt; #成功切换到目标目录 批处理中启动另外批处理文件 call ：启动一个成功或手动关闭后才会执行下一个bat文件 start：不会发生阻塞，并行启动 Windows配置服务（命令行） SC 是用于与服务控制管理器通信的命令行程序。 用法:\nsc \u0026lt;server\u0026gt; [command] [service name] \u0026lt;option1\u0026gt; \u0026lt;option2\u0026gt;... 选项 \u0026lt;server\u0026gt; 的格式为 可以键入 \u0026#34;sc [command]\u0026#34;以获得命令的进一步帮助 命令: query---------------查询服务的状态，或枚举服务类型的状态。 queryex------------查询服务的扩展状态， 或枚举服务类型的状态。 start----------------启动服务。 pause--------------发送 PAUSE 控制请求到服务。 interrogate--------发送 INTERROGATE 控制请求到服务。 continue-----------发送 CONTINUE 控制请求到服务。 stop----------------发送 STOP 请求到服务。 config--------------(永久地)更改服务的配置。 description--------更改服务的描述。 failure--------------更改服务失败时所进行的操作。 qc-------------------查询服务的配置信息。 qdescription-------查询服务的描述。 qfailure-------------查询失败服务所进行的操作。 delete---------------(从注册表)删除服务。 create---------------创建服务(将其添加到注册表)。 control--------------发送控制到服务。 sdshow--------------显示服务的安全描述符。 sdset----------------设置服务的安全描述符。 GetDisplayName---获取服务的 DisplayName。 GetKeyName--------获取服务的 ServiceKeyName。 EnumDepend-------枚举服务的依存关系。 下列命令不查询服务名称: sc \u0026lt;server\u0026gt; \u0026lt;command\u0026gt; \u0026lt;option\u0026gt; boot---------------(ok | bad) 表明是否将上一次启动保存为最后所知的好的启动配置 Lock---------------锁定服务数据库 QueryLock-------查询 SCManager 数据库的 LockStatus 使用 在出现的命令行窗口(开始-\u0026gt;运行-\u0026gt;cmd)中输入sc 使用sc/?命令，查询其它功能 示例 1:注册服务(类似与linux中系统启动自动加载的东西)\nsc create SVN binpath= \u0026#34;C:\\Program Files\\Subversion\\bin\\svnserve.exe --service -r D:\\svn\u0026#34; displayname= \u0026#34;Subversion Server\u0026#34; depend= Tcpip start= auto 其中sc create是sc注册服务命令 svn : 是服务注册时的键名 binpath : 是服务加载程序启动文件的路径和命令参数 displayname ：是服务显示名 depend ：传输依赖的协议 start ：是否自动启动 说明：上面的那个例子是注册一个svn的服务 示例 2:启动服务\nsc start MyService windows 相关操作 1. 远程桌面 mstsc 2. 查看服务 win+R--\u0026gt;services.msc 3. 查看端口占用 netstat -ano | findstr 10086 ","date":"2017-10-31","permalink":"https://blog.singasoong.top/posts/windows%E7%AC%94%E8%AE%B0/","summary":"Windows关闭/开启管理员用户 # 管理员权限进入cmd net user administrator /active:tes // 开启 net user administrator /active:no // 关闭 Windows批处理（.bat） .bat脚本示例 @echo off rem 准","tags":["笔记"],"title":"windows相关"},{"categories":null,"contents":"","date":"2017-10-29","permalink":"https://blog.singasoong.top/posts/hello-world/","summary":"","tags":null,"title":"初入Hugo"}]